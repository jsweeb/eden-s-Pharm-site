(function (global, factory) {
    global.Popper = factory();
}(this, function () {
    'use strict';
    
    function getStyleComputedProperty(element, property) {
        if (element.nodeType !== 1) {
            return [];
        }
        var window = element.ownerDocument.defaultView;
        var computedStyle = window.getComputedStyle(element, null);
        return property ? computedStyle[property] : computedStyle;
    }

    function getParentNode(element) {
        return element.nodeName === 'HTML' ? element : element.parentNode || element.host;
    }

    function getScrollParent(element) {
        if (!element) {
            return document.body;
        }

        switch (element.nodeName) {
            case 'HTML':
            case 'BODY':
                return element.ownerDocument.body;
            case '#document':
                return element.body;
        }

        var overflow = getStyleComputedProperty(element);
        var overflowRegex = /(auto|scroll|overlay)/;
        if (overflowRegex.test(overflow.overflow + overflow.overflowY + overflow.overflowX)) {
            return element;
        }

        return getScrollParent(getParentNode(element));
    }

    function getOffsetParent(element) {
        var noOffsetParent = navigator.userAgent.indexOf('MSIE 10') !== -1 ? document.body : null;
        if (!element) {
            return document.documentElement;
        }

        var offsetParent = element.offsetParent || null;

        while (offsetParent === noOffsetParent && element.nextElementSibling) {
            offsetParent = (element = element.nextElementSibling).offsetParent;
        }

        var nodeName = offsetParent && offsetParent.nodeName;

        if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
            return element ? element.ownerDocument.documentElement : document.documentElement;
        }

        if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&
            getStyleComputedProperty(offsetParent, 'position') === 'static') {
            return getOffsetParent(offsetParent);
        }

        return offsetParent;
    }

    function isFixed(element) {
        var nodeName = element.nodeName;
        if (nodeName === 'BODY' || nodeName === 'HTML') {
            return false;
        }
        if (getStyleComputedProperty(element, 'position') === 'fixed') {
            return true;
        }
        return isFixed(getParentNode(element));
    }

    // Fallback for findCommonOffsetParent
    function findCommonOffsetParent(popper, reference) {
        return getOffsetParent(reference);
    }

    // Fallback for getViewportOffsetRectRelativeToArbitraryNode
    function getViewportOffsetRectRelativeToArbitraryNode() {
        return { top: 0, left: 0, bottom: window.innerHeight, right: window.innerWidth };
    }

    // Fallback for getOffsetRectRelativeToArbitraryNode
    function getOffsetRectRelativeToArbitraryNode(element) {
        var rect = element.getBoundingClientRect();
        return {
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height
        };
    }

    // Fallback for getWindowSizes
    function getWindowSizes() {
        return {
            height: window.innerHeight,
            width: window.innerWidth
        };
    }

    function getBoundaries(popper, reference, padding, boundariesElement, fixedPosition = false) {
        var boundaries = { top: 0, left: 0 };
        var offsetParent = fixedPosition ? getOffsetParent(popper) : findCommonOffsetParent(popper, reference);

        if (boundariesElement === 'viewport') {
            boundaries = getViewportOffsetRectRelativeToArbitraryNode(offsetParent, fixedPosition);
        } else {
            var boundariesNode = void 0;
            if (boundariesElement === 'scrollParent') {
                boundariesNode = getScrollParent(getParentNode(reference));

                if (boundariesNode.nodeName === 'BODY') {
                    boundariesNode = popper.ownerDocument.documentElement;
                }
            } else if (boundariesElement === 'window') {
                boundariesNode = popper.ownerDocument.documentElement;
            } else {
                boundariesNode = boundariesElement;
            }

            var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

            if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
                var windowSizes = getWindowSizes();
                boundaries.top += offsets.top - offsets.marginTop;
                boundaries.bottom = windowSizes.height + offsets.top;
                boundaries.left += offsets.left - offsets.marginLeft;
                boundaries.right = windowSizes.width + offsets.left;
            } else {
                boundaries = offsets;
            }
        }

        padding = padding || 0;
        var isPaddingNumber = typeof padding === 'number';
        boundaries.left += isPaddingNumber ? padding : padding.left || 0;
        boundaries.top += isPaddingNumber ? padding : padding.top || 0;
        boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
        boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

        return boundaries;
    }

    return {
        getScrollParent: getScrollParent,
        getOffsetParent: getOffsetParent,
        getBoundaries: getBoundaries,
    };
}));
